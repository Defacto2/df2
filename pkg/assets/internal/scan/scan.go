package scan

import (
	"archive/tar"
	"errors"
	"flag"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"text/tabwriter"
	"time"

	"github.com/Defacto2/df2/pkg/assets/internal/file"
	"github.com/Defacto2/df2/pkg/database"
	"github.com/Defacto2/df2/pkg/directories"
	"github.com/Defacto2/df2/pkg/str"
	"github.com/dustin/go-humanize"
	"github.com/gookit/color"
)

var (
	ErrDir    = errors.New("directory to backup is missing")
	ErrBackup = errors.New("directory to save tar backup files is missing")
	ErrNil    = errors.New("parameter cannot be nil")
	ErrTarget = errors.New("unknown target")
)

// Scan a directory.
type Scan struct {
	Path   string       // Path to scan.
	Delete bool         // Delete any detected orphan files.
	Human  bool         // Human humanizes any byte values.
	IDs    database.IDs // IDs fetched from the database.
}

// Results of a directory scan.
type Results struct {
	Count int   // Count the number of results
	Fails int   // Fails are the sum of errors
	Bytes int64 // Bytes is sum total of file sizes.
}

type (
	// Files are unique UUID values used by the database and filenames.
	Files map[string]struct{}

	part map[string]string
)

// Calculate and save the results.
func (sum *Results) Calculate(w io.Writer, s Scan, d *directories.Dir) error {
	if d == nil {
		return directories.ErrNil
	}
	if w == nil {
		w = io.Discard
	}
	r, err := s.scanPath(w, d)
	if err != nil {
		return fmt.Errorf("sum calculate: %w", err)
	}
	sum.Bytes += r.Bytes
	sum.Count += r.Count
	sum.Fails += r.Fails
	return nil
}

func (s *Scan) archive(skip Files, list *[]os.FileInfo) Files {
	f := Files{}
	if list == nil || len(*list) == 0 {
		return f
	}
	for _, file := range *list {
		if file.IsDir() {
			continue
		}
		name := file.Name()
		if _, ok := skip[name]; ok {
			continue
		}
		uuid := strings.TrimSuffix(name, filepath.Ext(name))
		// search mapped IDs for a UUID value
		if _, ok := s.IDs[uuid]; !ok {
			f[name] = database.Empty{}
		}
	}
	return f
}

// scanPath gets a list of filenames located in s.Path and matches the Results
// against the list generated by CreateUUIDMap.
func (s Scan) scanPath(w io.Writer, d *directories.Dir) (Results, error) {
	if d == nil {
		return Results{}, directories.ErrNil
	}
	if w == nil {
		w = io.Discard
	}
	fmt.Fprintln(w, color.Primary.Sprintf("\nResults from %v", s.Path))
	// query file system
	entries, err := os.ReadDir(s.Path)
	if err != nil {
		var e *os.PathError
		if !errors.As(err, &e) {
			return Results{}, fmt.Errorf("scan path readdir %q: %w", s.Path, err)
		}
		fmt.Fprintln(w, color.Warn.Sprint("assets scanpath: no such directory"))
	}
	list := make([]fs.FileInfo, 0, len(entries))
	for _, e := range entries {
		if e.IsDir() {
			continue
		}
		i, err := e.Info()
		if err != nil {
			return Results{}, fmt.Errorf("entry info: %w", err)
		}
		list = append(list, i)
	}
	// files to ignore
	skip, err := Skip(s.Path, d)
	if err != nil {
		return Results{}, err
	}
	// archive files that are to be deleted
	if s.Delete {
		if err = Backup(w, skip, &list, &s, d); err != nil {
			return Results{}, fmt.Errorf("scan path backup: %w", err)
		}
	}
	// list and if requested, delete orphaned files
	stat, err := parse(w, &s, skip, &list)
	if err != nil {
		return stat, fmt.Errorf("scan path parse: %w", err)
	}
	st := fmt.Sprintf("%v B", stat.Bytes)
	if s.Human {
		st = humanize.Bytes(uint64(stat.Bytes))
	}
	fmt.Fprintf(w, "\n%v orphaned files\n%v drive space consumed\n", stat.Count, st)
	// number of orphaned files discovered, deletion failures, their cumulative size in bytes
	return stat, nil
}

// Skip is used by scanPath to filter files that should not be erased.
func Skip(path string, d *directories.Dir) (Files, error) {
	if d == nil {
		return Files{}, directories.ErrNil
	}
	empty := database.Empty{}
	ignore := Files{}
	ignore["00000000-0000-0000-0000-000000000000"] = empty
	ignore["blank.png"] = empty
	if path == d.Emu {
		ignore["g_drive.zip"] = empty
		ignore["s_drive.zip"] = empty
		ignore["u_drive.zip"] = empty
		ignore["dosee-core.js"] = empty
		ignore["dosee-core.mem"] = empty
	}
	return ignore, nil
}

// Backup is used by scanPath to backup matched orphans.
func Backup(w io.Writer, skip Files, list *[]os.FileInfo, s *Scan, d *directories.Dir) error {
	if list == nil {
		return fmt.Errorf("backup list: %w", ErrNil)
	}
	if s == nil {
		return fmt.Errorf("backup s: %w", ErrNil)
	}
	if d == nil {
		return fmt.Errorf("backup d: %w", ErrNil)
	}
	if s.Path == "" {
		return fmt.Errorf("backup scan path: %w", file.ErrEmptyPath)
	}
	if w == nil {
		w = io.Discard
	}
	test := false
	if flag.Lookup("test.v") != nil {
		test = true
	}
	f := s.archive(skip, list)
	// identify which files should be backed up
	d, p := backupParts(d)
	if test {
		p[s.Path] = "test"
	}
	if _, ok := p[s.Path]; ok {
		if err := s.backupPart(w, f, d, p, test); err != nil {
			return fmt.Errorf("backup part: %w", err)
		}
	}
	return nil
}

func backupParts(d *directories.Dir) (*directories.Dir, part) {
	p := part{}
	p[d.UUID] = "uuid"
	p[d.Img400] = "img-400xthumbs"
	p[d.Img000] = "img-captures"
	return d, p
}

func (s *Scan) backupPart(w io.Writer, f Files, d *directories.Dir, p part, test bool) error {
	t := time.Now().Format("2006-Jan-2-150405") // Mon Jan 2 15:04:05 MST 2006
	name := filepath.Join(d.Backup, fmt.Sprintf("bak-%v-%v.tar", p[s.Path], t))
	base := s.Path
	dst, err := s.walker(d, base, name)
	if err != nil {
		return err
	}
	tw := tar.NewWriter(dst)
	defer tw.Close()
	c := 0
	// walk through `path` and match any files marked for deletion
	// Partial source: https://github.com/cloudfoundry/archiver/blob/master/compressor/write_tar.go
	err = filepath.Walk(s.Path, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return fmt.Errorf("walk %q: %w", path, err)
		}
		wlkname, err := file.WalkName(base, path)
		if err != nil {
			return fmt.Errorf("walk name %q: %w", path, err)
		}
		if _, ok := f[wlkname]; ok || test {
			c++
			if c == 1 {
				fmt.Fprint(w, "archiving these files before deletion\n\n")
			}
			if err := file.Write(tw, path, name); err != nil {
				return fmt.Errorf("write tar %q: %w", path, err)
			}
		}
		return nil // no match
	})
	// if backup fails, then abort deletion
	if err != nil || c == 0 {
		// clean up any loose archives
		dst.Close()
		if err := os.Remove(name); err != nil {
			return fmt.Errorf("cleanup remove %q: %w", name, err)
		}
	}
	return nil
}

func (s *Scan) walker(d *directories.Dir, base, name string) (*os.File, error) {
	_, err := os.Stat(base)
	if os.IsNotExist(err) {
		return nil, fmt.Errorf("create %q: %w", base, ErrDir)
	}
	_, err = os.Stat(d.Backup)
	if os.IsNotExist(err) {
		return nil, fmt.Errorf("create %q: %w", d.Backup, ErrBackup)
	}
	// create tar archive
	f, err := os.Create(name)
	if err != nil {
		return nil, fmt.Errorf("create %q: %w", name, err)
	}
	return f, nil
}

type item struct {
	name  string // os.FileInfo.Name()
	path  string // filepath
	flag  string // check tick, mark or blank
	human bool   // humanise sizes
	cnt   string // loop count
	fm    string // file mode
	fs    string // file size
	mt    string // file modified time
}

// parse is used by scanPath to remove matched orphans.
func parse(w io.Writer, s *Scan, ignore Files, list *[]os.FileInfo) (Results, error) {
	if w == nil {
		w = io.Discard
	}
	const padding = 2
	stat := Results{Count: 0, Fails: 0, Bytes: 0}
	for _, file := range *list {
		if file.IsDir() {
			continue // ignore directories
		}
		if _, ign := ignore[file.Name()]; ign {
			continue // ignore files
		}
		i := item{human: s.Human, name: file.Name()}
		uuid := strings.TrimSuffix(i.name, filepath.Ext(i.name))
		tw := tabwriter.NewWriter(w, 0, 0, padding, ' ', 0)
		if _, ok := s.IDs[uuid]; !ok {
			stat.totals(file)
			if s.Delete {
				i.path = path.Join(s.Path, file.Name())
				i.erase(stat)
			}
			i.count(stat.Count)
			i.mod(file)
			i.size(file)
			i.bits(file)
			fmt.Fprintf(tw, "%v\t%v %v\t%v\t%v\t%v\n",
				i.cnt, i.flag, i.name, i.fs, i.fm, i.mt)
		}
		if err := tw.Flush(); err != nil {
			return stat, fmt.Errorf("parse tabwriter flush: %w", err)
		}
	}
	return stat, nil
}

func (i *item) bits(f os.FileInfo) {
	i.fm = color.Note.Sprint(f.Mode())
}

func (i *item) count(c int) {
	i.cnt = color.Secondary.Sprint(strconv.Itoa(c) + ".")
}

func (i *item) erase(r Results) {
	i.flag = str.Y()
	if err := os.Remove(i.path); err != nil {
		i.flag = str.X()
		r.Fails++
	}
}

func (i *item) mod(f os.FileInfo) {
	s := fmt.Sprint(f.ModTime())
	if i.human {
		// show date and time
		s = f.ModTime().Format("02 Jan 15:04")
		if time.Now().Year() != f.ModTime().Year() {
			// otherwise, hide the time and show the year
			s = f.ModTime().Format("02 Jan 2006")
		}
	}
	i.mt = color.Primary.Sprint(s)
}

func (i *item) size(f os.FileInfo) {
	s := fmt.Sprint(f.Size())
	if i.human {
		s = humanize.Bytes(uint64(f.Size()))
	}
	i.fs = color.Comment.Sprint(s)
}

func (sum *Results) totals(f os.FileInfo) {
	sum.Count++
	sum.Bytes += f.Size()
}
